#include <stdio.h>
#include <iostream>
#include <vector>
#include <algorithm> // 必须包含这个头文件
// --- ImGui 和后端 ---
#include <imgui.h>
#include <backends/imgui_impl_glfw.h>
#include <backends/imgui_impl_opengl3.h>

// --- GLFW ---
#include <glad/glad.h> 
#include <GLFW/glfw3.h> 
// 【新增】手动包含 OpenGL 头文件
// 因为 xmake 的 imgui 包可能会阻止 glfw 自动包含它
// #if defined(_WIN32)
//     #include <windows.h> // Windows 下 OpenGL 依赖这个
//     #include <GL/gl.h>   // 包含 glViewport, glClear 等标准函数
// #else
//     #include <GL/gl.h>
// #endif

const int canvas_width = 1280 - 300;
const int canvas_height = 720;
GLuint fbo;
GLuint baked_texture;


// ... 后面代码不变 ...
// 这是一个错误回调函数，如果 GLFW 出错了（比如窗口创建失败），会在这里打印
static void glfw_error_callback(int error, const char* description) {
    fprintf(stderr, "GLFW Error %d: %s\n", error, description);
}

void create_mouse_debugger() {
    ImGui::Begin("Mouse Debugger"); // 创建一个窗口调试鼠标

    // 1. 获取鼠标当前在屏幕上的坐标
    // ImGuiIO 是 ImGui 的输入输出控制结构体，存着所有输入信息
    ImGuiIO& io = ImGui::GetIO();
    ImVec2 mouse_pos = io.MousePos; 

    // 显示坐标
    ImGui::Text("Mouse Position: (%.1f, %.1f)", mouse_pos.x, mouse_pos.y);
    ImGui::Separator();

    // 2. 检测按下瞬间 (只触发一次)
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
        // 这里以后就是： strok_list.push_back(new_stroke);
        ImGui::Text("Event: Just Clicked! (Start Drawing)"); 
    }

    // 3. 检测持续按住 (持续触发)
    if (ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
        // 这里以后就是： current_stroke.points.push_back(mouse_pos);
        ImGui::TextColored(ImVec4(0, 1, 0, 1), "Status: HOLDING LEFT BUTTON"); // 绿色文字
    } else {
        ImGui::TextColored(ImVec4(0.5, 0.5, 0.5, 1), "Status: Idle"); // 灰色文字
    }

    // 4. 检测松开瞬间 (只触发一次)
    if (ImGui::IsMouseReleased(ImGuiMouseButton_Left)) {
        // 这里以后就是： save_stroke_to_history();
        ImGui::Text("Event: Released! (Finish Drawing)");
    }

    ImGui::End();

    // ==========================================
    // >>> UI 代码结束 <<<
    // ==========================================

}

void draw_debug() {
    // ImGui::Begin("Canvas");

    // 1. 获取当前 UI 窗口在屏幕上的起始位置（像素）
    ImVec2 p0 = ImGui::GetCursorScreenPos(); 

    // 2. 获取绘图列表
    ImDrawList* draw_list = ImGui::GetWindowDrawList();

    // 3. 定义颜色 (格式：ABGR，这里是红色，透明度 255)
    // 或者使用 IM_COL32(R, G, B, A) 宏
    ImU32 red_color = IM_COL32(255, 0, 0, 255);
    ImU32 blue_color = IM_COL32(0, 0, 255, 255);

    // 4. 绘制一个 100x100 的矩形框作为参考
    ImVec2 p1 = ImVec2(p0.x + 100, p0.y + 100);
    draw_list->AddRect(p0, p1, IM_COL32(255, 255, 255, 255));

    // 5. 【以像素为单位画画】
    // 假设我们要相对于窗口左上角 (20, 20) 的位置画一个点
    float x = 20.0f;
    float y = 20.0f;
    ImVec2 target_point = ImVec2(p0.x + x, p0.y + y);

    // 画一个圆点 (圆心，半径，颜色)
    draw_list->AddCircleFilled(target_point, 5.0f, red_color);

    // 画一条线 (起点，终点，颜色，粗细)
    draw_list->AddLine(p0, ImGui::GetMousePos(), blue_color, 2.0f);

}

struct Stroke {
    std::vector<ImVec2> points;
    ImU32 color;
    float thickness;
};

// 全局变量
std::vector<Stroke> g_strokes;
bool g_is_drawing = false;
float distance(ImVec2 p1, ImVec2 p2) {
    return sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
ImU32 red_color = IM_COL32(255, 0, 0, 255);
ImU32 blue_color = IM_COL32(0, 0, 255, 255);

// 笔刷大小
static float g_brushSize = 5.0f; 

// 笔刷颜色 (ImVec4 方便 UI 编辑，通常是 RGBA)
static ImVec4 g_brushColor = ImVec4(1.0f, 0.0f, 0.0f, 1.0f); // 默认红色



void check_brush(ImDrawList* draw_list) {
    // 在 Canvas 窗口内
    ImVec2 mouse_pos = ImGui::GetMousePos();
    // draw_list->AddCircleFilled(mouse_pos, g_brushSize, red_color);
    draw_list->AddCircle(mouse_pos, g_brushSize, blue_color, 0, 3);

    // 1. 开始画：按下左键的一瞬间
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
        g_is_drawing = true;
        Stroke new_stroke;
        ImU32 red   = IM_COL32(255, 0, 0, 255);

        ImU32 current_color = red;
        new_stroke.color = ImGui::ColorConvertFloat4ToU32(g_brushColor);     // 比如你从 UI 选的颜色
        int current_size = 19;
        new_stroke.thickness = g_brushSize;  // 比如你滑块选的大小
        new_stroke.points.push_back(mouse_pos);
        g_strokes.push_back(new_stroke);
    }

    // 2. 正在画：按住不放期间
    if (g_is_drawing && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
        // 只有当鼠标移动了一定距离才记录点，防止点太密集
        Stroke& current_stroke = g_strokes.back();
        float dist_sq = distance(current_stroke.points.back(), mouse_pos);/* 计算当前点和上一个点的距离平方 */;
        if (dist_sq > 4.0f) { // 移动超过2像素才记录
            current_stroke.points.push_back(mouse_pos);
        }
    }

    // 3. 结束画
    if (g_is_drawing && ImGui::IsMouseReleased(ImGuiMouseButton_Left)) {
        g_is_drawing = false;
    }

    
}

enum class Tool {
    None,
    Brush,
    Eraser
};
Tool g_currentTool = Tool::Brush; // 默认使用画笔

void check_eraser(ImDrawList* draw_list) {
    const float eraser_radius = g_brushSize;
    ImVec2 mouse_pos = ImGui::GetMousePos();
    draw_list->AddCircle(mouse_pos, eraser_radius, blue_color, 0, 3);
// draw_list->AddCircle(center, radius, color, 0, thickness);
    // 1. 开始画：按下左键的一瞬间
    if (ImGui::IsMouseClicked(ImGuiMouseButton_Left)) {
        g_is_drawing = true; 
    }

    // 2. 正在画：按住不放期间
    if (g_is_drawing && ImGui::IsMouseDown(ImGuiMouseButton_Left)) {
        // 只有当鼠标移动了一定距离才记录点，防止点太密集
        
        auto it = std::remove_if(g_strokes.begin(), g_strokes.end(), [&](const Stroke& s) {
        // 这里的逻辑：如果这个笔画应该被删除，返回 true
            for (const auto& p : s.points) {
                float dx = p.x - mouse_pos.x;
                float dy = p.y - mouse_pos.y;
                float r = eraser_radius + s.thickness;
                if (dx * dx + dy * dy < r * r) {
                    return true; // 碰到橡皮擦了，标记删除
                }
            }
            return false; // 没碰到，保留
        });

        // 真正地把末尾的元素清理掉
        g_strokes.erase(it, g_strokes.end());
    }

    // 3. 结束画
    if (g_is_drawing && ImGui::IsMouseReleased(ImGuiMouseButton_Left)) {
        g_is_drawing = false;
    }

}

void render(ImDrawList* draw_list) {
    for (const auto& stroke : g_strokes) {
        if (stroke.points.size() < 2) continue;
        // 使用 AddPolyline 绘制折线
        draw_list->AddPolyline(stroke.points.data(), (int)stroke.points.size(), stroke.color, 0, stroke.thickness);
    }
}
bool g_NeedsBake = false;

void BakeStrokesToTexture() {
    // 1. 绑定 FBO，接下来的渲染指令会画到纹理上，而不是屏幕
    glBindFramebuffer(GL_FRAMEBUFFER, fbo);
    glViewport(0, 0, canvas_width, canvas_height);

    // 2. 这里是关键：我们要用 OpenGL 指令画出所有的 Stroke
    // 方案：最简单的方法是使用 ImGui 专门渲染 FBO 的功能
    // 但为了让你理解原理，你可以手动用简单的 OpenGL 指令，或者...
    // 我们可以借用 ImGui 的绘制数据。
    
    // 【简化方案】如果你不想写复杂的 Shader，可以先用 ImGui 的渲染函数：
    ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
    
    // 3. 清空笔画，完成“固化”
    g_strokes.clear();

    // 4. 回到屏幕渲染
    glBindFramebuffer(GL_FRAMEBUFFER, 0);
}



void create_canvas() {
    ImGui::SetNextWindowPos(ImVec2(300, 0));  // 设置位置 (x, y)
    ImGui::SetNextWindowSize(ImVec2(1280 - 300, 720)); // 设置大小 (宽, 高)

    // 2. 创建窗口（NoTitleBar 移除标题栏，NoMove 禁止移动）
    ImGuiWindowFlags flags = ImGuiWindowFlags_NoTitleBar | 
                            ImGuiWindowFlags_NoMove |
                            ImGuiWindowFlags_NoResize;  // 可选：禁止调整大小

    ImGui::Begin("Canvas", nullptr, flags);
    // 获取当前画布在屏幕上的起始坐标 p0
    ImVec2 p0 = ImGui::GetCursorScreenPos();
    ImVec2 sz = ImVec2((float)canvas_width, (float)canvas_height);
    ImDrawList* draw_list = ImGui::GetWindowDrawList();

    draw_list->AddImage((ImTextureID)(intptr_t)baked_texture, p0, ImVec2(p0.x + sz.x, p0.y + sz.y));

    // ImDrawList* draw_list = ImGui::GetWindowDrawList();
    if (g_currentTool == Tool::Brush) check_brush(draw_list);
    if (g_currentTool == Tool::Eraser) check_eraser(draw_list);
    render(draw_list);

    ImGui::End();
}

void create_sidebar(GLFWwindow* window) {
    ImGui::SetNextWindowPos(ImVec2(0, 0));  // 设置位置 (x, y)
    ImGui::SetNextWindowSize(ImVec2(300, 720)); // 设置大小 (宽, 高)

    // 2. 创建窗口（NoTitleBar 移除标题栏，NoMove 禁止移动）
    ImGuiWindowFlags flags = ImGuiWindowFlags_NoTitleBar | 
                            ImGuiWindowFlags_NoMove |
                            ImGuiWindowFlags_NoResize;  // 可选：禁止调整大小

    // 创建一个名为 "Tools" 的窗口
    ImGui::Begin("Tools");

    // 1. 工具选择 (你之前的 enum)
    if (ImGui::RadioButton("Brush", g_currentTool == Tool::Brush)) g_currentTool = Tool::Brush;
    ImGui::SameLine(); // 让下一个控件在同一行
    if (ImGui::RadioButton("Eraser", g_currentTool == Tool::Eraser)) g_currentTool = Tool::Eraser;

    ImGui::Separator(); // 画一条分割线

    // 2. 笔刷大小调节
    // 参数：标签，变量地址，最小值，最大值，格式化字符串（可选）
    ImGui::Text("Brush Settings");
    ImGui::SliderFloat("Size", &g_brushSize, 1.0f, 50.0f, "%.1f px");

    // 3. 取色框
    // 参数：标签，颜色数组(float*), 配置标记
    ImGui::ColorEdit4("Color", (float*)&g_brushColor, ImGuiColorEditFlags_NoInputs | ImGuiColorEditFlags_AlphaBar);

    // 如果你想显示一个永远展开的大调色盘，可以用这个：
    // ImGui::ColorPicker4("Picker", (float*)&g_brushColor);
    if (ImGui::Button("Bake")) {
        // BakeStrokesToTexture();
        g_NeedsBake = true;
    }
    // 4. 一个快捷的小按钮：清空画布
    if (ImGui::Button("Clear All")) {
        g_strokes.clear();
    }

    ImGui::End();
}


int main(int, char**) {
    // --- 1. 初始化窗口系统 (GLFW) ---
    glfwSetErrorCallback(glfw_error_callback);
    if (!glfwInit()) return 1;

    // 告诉 GLFW 我们要用 OpenGL 3.3 版本
    const char* glsl_version = "#version 330";
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);

    // 创建一个 1280x720 的窗口
    GLFWwindow* window = glfwCreateWindow(1280, 720, "My Paint App", NULL, NULL);
    if (window == NULL) return 1;
    
    // 把这个窗口设为当前绘图上下文
    glfwMakeContextCurrent(window);
    glfwSwapInterval(1); // 开启垂直同步，防止画面撕裂
    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress)) {
        printf("Failed to initialize GLAD\n");
        return -1;
    }


    // --- 2. 初始化 ImGui ---
    IMGUI_CHECKVERSION();
    ImGui::CreateContext();
    ImGuiIO& io = ImGui::GetIO(); (void)io;
    
    // 设置一下风格，这里选深色主题，看着专业点
    // ImGui::StyleColorsDark();

    // 绑定 ImGui 到 GLFW 和 OpenGL
    ImGui_ImplGlfw_InitForOpenGL(window, true);
    ImGui_ImplOpenGL3_Init(glsl_version);


    // 1. 定义画布的分辨率（你可以根据窗口大小定，也可以定死，比如 2000x2000

    // 2. 创建纹理（这就是你的“底片”）
    glGenTextures(1, &baked_texture);
    glBindTexture(GL_TEXTURE_2D, baked_texture);
    // 初始化为空白（全透明或全白）
    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, canvas_width, canvas_height, 0, GL_RGBA, GL_UNSIGNED_BYTE, NULL);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);

    // 3. 创建 FBO（它是用来把东西“画”进纹理的工具）
    glGenFramebuffers(1, &fbo);
    glBindFramebuffer(GL_FRAMEBUFFER, fbo);
    // 把纹理挂载到 FBO 上
    glFramebufferTexture2D(GL_FRAMEBUFFER, GL_COLOR_ATTACHMENT0, GL_TEXTURE_2D, baked_texture, 0);

    // 检查是否创建成功
    if(glCheckFramebufferStatus(GL_FRAMEBUFFER) != GL_FRAMEBUFFER_COMPLETE)
        printf("FBO Error!\n");

    // 暂时解绑，回到默认屏幕渲染
    glBindFramebuffer(GL_FRAMEBUFFER, 0);

    // --- 3. 核心循环 (Game Loop) ---
    // 只要窗口没被关闭，就一直跑
    while (!glfwWindowShouldClose(window)) {
        glfwPollEvents();
        ImGui_ImplOpenGL3_NewFrame();
        ImGui_ImplGlfw_NewFrame();
        ImGui::NewFrame();

        create_sidebar(window);
        create_canvas();

        // 1. 先生成本帧的渲染数据
        ImGui::Render(); 

        // 2. 【核心修复】在这里判断是否需要 Bake
        if (g_NeedsBake) {
            glBindFramebuffer(GL_FRAMEBUFFER, fbo);
            // 注意：因为我们要把线画到纹理上，纹理坐标通常是 (0,0) 到 (w,h)
            glViewport(0, 0, canvas_width, canvas_height);
            
            // 关键：只把本帧的数据渲染进 FBO
            // 注意：这会把整个屏幕（包括工具栏）都画进纹理，后面我会教你如何只画笔划
            ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
            
            glBindFramebuffer(GL_FRAMEBUFFER, 0);
            g_strokes.clear(); // 清空矢量笔划
            g_NeedsBake = false;
        }

        // 3. 最后渲染到主屏幕
        int display_w, display_h;
        glfwGetFramebufferSize(window, &display_w, &display_h);
        glViewport(0, 0, display_w, display_h);
        glClearColor(0.45f, 0.55f, 0.60f, 1.00f);
        glClear(GL_COLOR_BUFFER_BIT);
        
        ImGui_ImplOpenGL3_RenderDrawData(ImGui::GetDrawData());
        glfwSwapBuffers(window);
    }
    // --- 5. 清理战场 ---
    ImGui_ImplOpenGL3_Shutdown();
    ImGui_ImplGlfw_Shutdown();
    ImGui::DestroyContext();

    glfwDestroyWindow(window);
    glfwTerminate();

    return 0;
}